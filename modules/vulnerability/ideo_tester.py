#!/usr/bin/env python3
"""
IDOR (Insecure Direct Object Reference) Tester
- Horizontal privilege escalation
- Vertical privilege escalation
- Predictable ID enumeration
"""

import requests
import re
from urllib.parse import urlparse, parse_qs, urlencode

class IDORTester:
    def __init__(self, target_url):
        self.target = target_url
        self.vulnerabilities = []
        self.session = requests.Session()
        self.session.headers.update({'User-Agent': 'IDORTester/2.0'})
    
    def scan_all(self, endpoints):
        """Main IDOR testing orchestrator"""
        for endpoint in endpoints:
            self._test_numeric_ids(endpoint)
            self._test_uuid_manipulation(endpoint)
            self._test_username_enumeration(endpoint)
        
        return self.vulnerabilities
    
    def _test_numeric_ids(self, url):
        """Test numeric ID manipulation"""
        parsed = urlparse(url)
        params = parse_qs(parsed.query)
        
        # Look for numeric ID parameters
        id_params = ['id', 'user_id', 'userid', 'uid', 'account', 'profile']
        
        for param_name in params.keys():
            if any(id_param in param_name.lower() for id_param in id_params):
                original_value = params[param_name][0]
                
                # Check if numeric
                if original_value.isdigit():
                    try:
                        # Get baseline response
                        baseline = self.session.get(url, timeout=10)
                        baseline_length = len(baseline.text)
                        
                        # Test with incremented ID
                        test_id = str(int(original_value) + 1)
                        test_params = params.copy()
                        test_params[param_name] = [test_id]
                        test_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}?{urlencode(test_params, doseq=True)}"
                        
                        test_response = self.session.get(test_url, timeout=10)
                        
                        # If we get data back (not error/redirect), likely IDOR
                        if test_response.status_code == 200 and len(test_response.text) > baseline_length * 0.5:
                            # Check if content is different but similar structure
                            if self._responses_similar_structure(baseline.text, test_response.text):
                                self.vulnerabilities.append({
                                    'tool': 'idor_tester',
                                    'type': 'Insecure Direct Object Reference',
                                    'name': 'IDOR (Horizontal Privilege Escalation)',
                                    'severity': 'high',
                                    'url': test_url,
                                    'parameter': param_name,
                                    'original_id': original_value,
                                    'tested_id': test_id,
                                    'description': f"IDOR in '{param_name}' - can access other users' data by manipulating ID",
                                    'evidence': f"Original ID {original_value} â†’ Tested ID {test_id}: {test_response.status_code}",
                                    'remediation': self._get_remediation('numeric'),
                                    'cvss': 8.1
                                })
                    except:
                        pass
    
    def _test_uuid_manipulation(self, url):
        """Test UUID/GUID manipulation"""
        parsed = urlparse(url)
        params = parse_qs(parsed.query)
        
        uuid_pattern = re.compile(r'[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}', re.I)
        
        for param_name, values in params.items():
            value = values[0]
            
            if uuid_pattern.match(value):
                try:
                    # Get baseline
                    baseline = self.session.get(url, timeout=10)
                    
                    # Test with modified UUID (increment last character)
                    test_uuid = value[:-1] + ('0' if value[-1] != '0' else '1')
                    test_params = params.copy()
                    test_params[param_name] = [test_uuid]
                    test_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}?{urlencode(test_params, doseq=True)}"
                    
                    test_response = self.session.get(test_url, timeout=10)
                    
                    if test_response.status_code == 200 and 'not found' not in test_response.text.lower():
                        self.vulnerabilities.append({
                            'tool': 'idor_tester',
                            'type': 'IDOR via UUID',
                            'name': 'IDOR (Predictable UUIDs)',
                            'severity': 'high',
                            'url': test_url,
                            'parameter': param_name,
                            'description': f"IDOR via UUID manipulation in '{param_name}'",
                            'remediation': self._get_remediation('uuid')
                        })
                except:
                    pass
    
    def _test_username_enumeration(self, url):
        """Test username-based IDOR"""
        if '/user/' in url or '/profile/' in url or '/account/' in url:
            # Extract username/identifier from URL path
            parts = url.split('/')
            for i, part in enumerate(parts):
                if part in ['user', 'profile', 'account'] and i + 1 < len(parts):
                    original_username = parts[i + 1]
                    
                    # Test with common usernames
                    test_usernames = ['admin', 'test', 'user', 'administrator']
                    
                    for test_user in test_usernames:
                        if test_user != original_username:
                            try:
                                test_url = url.replace(original_username, test_user)
                                response = self.session.get(test_url, timeout=10)
                                
                                if response.status_code == 200 and len(response.text) > 500:
                                    self.vulnerabilities.append({
                                        'tool': 'idor_tester',
                                        'type': 'IDOR via Username',
                                        'name': 'IDOR (Username Enumeration)',
                                        'severity': 'medium',
                                        'url': test_url,
                                        'original_user': original_username,
                                        'tested_user': test_user,
                                        'description': 'Can access other users profiles by username',
                                        'remediation': self._get_remediation('username')
                                    })
                                    break
                            except:
                                pass
    
    def _responses_similar_structure(self, resp1, resp2):
        """Check if two responses have similar HTML structure"""
        # Simple heuristic: similar tag counts
        tags1 = len(re.findall(r'<[^>]+>', resp1))
        tags2 = len(re.findall(r'<[^>]+>', resp2))
        
        if tags1 == 0 or tags2 == 0:
            return False
        
        ratio = min(tags1, tags2) / max(tags1, tags2)
        return ratio > 0.7  # 70% similarity
    
    def _get_remediation(self, idor_type):
        """Get remediation advice"""
        remediations = {
            'numeric': 'Implement proper authorization checks. Use indirect references (mapping). Never rely on client-side access control.',
            'uuid': 'Verify user ownership before returning data. Implement session-based access control. Use cryptographically random UUIDs.',
            'username': 'Implement proper authentication and authorization. Check if current user has permission to view requested profile.'
        }
        return remediations.get(idor_type, 'Implement proper authorization checks for all object references.')